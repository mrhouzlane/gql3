"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity
is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

type AllocationClosedEvent {
  id: ID!
  staker: Bytes!
  amount: BigInt!
  escrow: Bytes!
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

input AllocationClosedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  staker: Bytes
  staker_not: Bytes
  staker_gt: Bytes
  staker_lt: Bytes
  staker_gte: Bytes
  staker_lte: Bytes
  staker_in: [Bytes!]
  staker_not_in: [Bytes!]
  staker_contains: Bytes
  staker_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  escrow: Bytes
  escrow_not: Bytes
  escrow_gt: Bytes
  escrow_lt: Bytes
  escrow_gte: Bytes
  escrow_lte: Bytes
  escrow_in: [Bytes!]
  escrow_not_in: [Bytes!]
  escrow_contains: Bytes
  escrow_not_contains: Bytes
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AllocationClosedEvent_filter]
  or: [AllocationClosedEvent_filter]
}

enum AllocationClosedEvent_orderBy {
  id
  staker
  amount
  escrow
  block
  timestamp
  transaction
}

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

input BlockChangedFilter {
  number_gte: Int!
}

type BulkTransferEvent {
  id: ID!
  escrow: Bytes!
  bulkCount: BigInt!
  txId: BigInt!
  amountPaid: BigInt
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
  count: BigInt
}

input BulkTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  escrow: Bytes
  escrow_not: Bytes
  escrow_gt: Bytes
  escrow_lt: Bytes
  escrow_gte: Bytes
  escrow_lte: Bytes
  escrow_in: [Bytes!]
  escrow_not_in: [Bytes!]
  escrow_contains: Bytes
  escrow_not_contains: Bytes
  bulkCount: BigInt
  bulkCount_not: BigInt
  bulkCount_gt: BigInt
  bulkCount_lt: BigInt
  bulkCount_gte: BigInt
  bulkCount_lte: BigInt
  bulkCount_in: [BigInt!]
  bulkCount_not_in: [BigInt!]
  txId: BigInt
  txId_not: BigInt
  txId_gt: BigInt
  txId_lt: BigInt
  txId_gte: BigInt
  txId_lte: BigInt
  txId_in: [BigInt!]
  txId_not_in: [BigInt!]
  amountPaid: BigInt
  amountPaid_not: BigInt
  amountPaid_gt: BigInt
  amountPaid_lt: BigInt
  amountPaid_gte: BigInt
  amountPaid_lte: BigInt
  amountPaid_in: [BigInt!]
  amountPaid_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BulkTransferEvent_filter]
  or: [BulkTransferEvent_filter]
}

enum BulkTransferEvent_orderBy {
  id
  escrow
  bulkCount
  txId
  amountPaid
  block
  timestamp
  transaction
  count
}

scalar Bytes

type DataSavedEvent {
  id: ID!
  leader: Bytes!
  key: String!
  value: String!
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

input DataSavedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  leader: Bytes
  leader_not: Bytes
  leader_gt: Bytes
  leader_lt: Bytes
  leader_gte: Bytes
  leader_lte: Bytes
  leader_in: [Bytes!]
  leader_not_in: [Bytes!]
  leader_contains: Bytes
  leader_not_contains: Bytes
  key: String
  key_not: String
  key_gt: String
  key_lt: String
  key_gte: String
  key_lte: String
  key_in: [String!]
  key_not_in: [String!]
  key_contains: String
  key_contains_nocase: String
  key_not_contains: String
  key_not_contains_nocase: String
  key_starts_with: String
  key_starts_with_nocase: String
  key_not_starts_with: String
  key_not_starts_with_nocase: String
  key_ends_with: String
  key_ends_with_nocase: String
  key_not_ends_with: String
  key_not_ends_with_nocase: String
  value: String
  value_not: String
  value_gt: String
  value_lt: String
  value_gte: String
  value_lte: String
  value_in: [String!]
  value_not_in: [String!]
  value_contains: String
  value_contains_nocase: String
  value_not_contains: String
  value_not_contains_nocase: String
  value_starts_with: String
  value_starts_with_nocase: String
  value_not_starts_with: String
  value_not_starts_with_nocase: String
  value_ends_with: String
  value_ends_with_nocase: String
  value_not_ends_with: String
  value_not_ends_with_nocase: String
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DataSavedEvent_filter]
  or: [DataSavedEvent_filter]
}

enum DataSavedEvent_orderBy {
  id
  leader
  key
  value
  block
  timestamp
  transaction
}

type EscrowStatistics {
  id: ID!
  intermediateStorageEventCount: BigInt!
  pendingEventCount: BigInt!
  bulkTransferEventCount: BigInt!
  totalEventCount: BigInt!
  totalEscrowCount: BigInt!
}

input EscrowStatistics_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  intermediateStorageEventCount: BigInt
  intermediateStorageEventCount_not: BigInt
  intermediateStorageEventCount_gt: BigInt
  intermediateStorageEventCount_lt: BigInt
  intermediateStorageEventCount_gte: BigInt
  intermediateStorageEventCount_lte: BigInt
  intermediateStorageEventCount_in: [BigInt!]
  intermediateStorageEventCount_not_in: [BigInt!]
  pendingEventCount: BigInt
  pendingEventCount_not: BigInt
  pendingEventCount_gt: BigInt
  pendingEventCount_lt: BigInt
  pendingEventCount_gte: BigInt
  pendingEventCount_lte: BigInt
  pendingEventCount_in: [BigInt!]
  pendingEventCount_not_in: [BigInt!]
  bulkTransferEventCount: BigInt
  bulkTransferEventCount_not: BigInt
  bulkTransferEventCount_gt: BigInt
  bulkTransferEventCount_lt: BigInt
  bulkTransferEventCount_gte: BigInt
  bulkTransferEventCount_lte: BigInt
  bulkTransferEventCount_in: [BigInt!]
  bulkTransferEventCount_not_in: [BigInt!]
  totalEventCount: BigInt
  totalEventCount_not: BigInt
  totalEventCount_gt: BigInt
  totalEventCount_lt: BigInt
  totalEventCount_gte: BigInt
  totalEventCount_lte: BigInt
  totalEventCount_in: [BigInt!]
  totalEventCount_not_in: [BigInt!]
  totalEscrowCount: BigInt
  totalEscrowCount_not: BigInt
  totalEscrowCount_gt: BigInt
  totalEscrowCount_lt: BigInt
  totalEscrowCount_gte: BigInt
  totalEscrowCount_lte: BigInt
  totalEscrowCount_in: [BigInt!]
  totalEscrowCount_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [EscrowStatistics_filter]
  or: [EscrowStatistics_filter]
}

enum EscrowStatistics_orderBy {
  id
  intermediateStorageEventCount
  pendingEventCount
  bulkTransferEventCount
  totalEventCount
  totalEscrowCount
}

type EventDayData {
  id: ID!
  timestamp: Int!
  dailyBulkTransferEvents: BigInt!
  dailyIntermediateStorageEvents: BigInt!
  dailyPendingEvents: BigInt!
  dailyEscrowAmounts: BigInt!
}

input EventDayData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  dailyBulkTransferEvents: BigInt
  dailyBulkTransferEvents_not: BigInt
  dailyBulkTransferEvents_gt: BigInt
  dailyBulkTransferEvents_lt: BigInt
  dailyBulkTransferEvents_gte: BigInt
  dailyBulkTransferEvents_lte: BigInt
  dailyBulkTransferEvents_in: [BigInt!]
  dailyBulkTransferEvents_not_in: [BigInt!]
  dailyIntermediateStorageEvents: BigInt
  dailyIntermediateStorageEvents_not: BigInt
  dailyIntermediateStorageEvents_gt: BigInt
  dailyIntermediateStorageEvents_lt: BigInt
  dailyIntermediateStorageEvents_gte: BigInt
  dailyIntermediateStorageEvents_lte: BigInt
  dailyIntermediateStorageEvents_in: [BigInt!]
  dailyIntermediateStorageEvents_not_in: [BigInt!]
  dailyPendingEvents: BigInt
  dailyPendingEvents_not: BigInt
  dailyPendingEvents_gt: BigInt
  dailyPendingEvents_lt: BigInt
  dailyPendingEvents_gte: BigInt
  dailyPendingEvents_lte: BigInt
  dailyPendingEvents_in: [BigInt!]
  dailyPendingEvents_not_in: [BigInt!]
  dailyEscrowAmounts: BigInt
  dailyEscrowAmounts_not: BigInt
  dailyEscrowAmounts_gt: BigInt
  dailyEscrowAmounts_lt: BigInt
  dailyEscrowAmounts_gte: BigInt
  dailyEscrowAmounts_lte: BigInt
  dailyEscrowAmounts_in: [BigInt!]
  dailyEscrowAmounts_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [EventDayData_filter]
  or: [EventDayData_filter]
}

enum EventDayData_orderBy {
  id
  timestamp
  dailyBulkTransferEvents
  dailyIntermediateStorageEvents
  dailyPendingEvents
  dailyEscrowAmounts
}

type HMApprovalEvent {
  id: ID!
  token: Bytes!
  owner: Bytes!
  spender: Bytes!
  value: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
  count: BigInt
}

input HMApprovalEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  spender: Bytes
  spender_not: Bytes
  spender_gt: Bytes
  spender_lt: Bytes
  spender_gte: Bytes
  spender_lte: Bytes
  spender_in: [Bytes!]
  spender_not_in: [Bytes!]
  spender_contains: Bytes
  spender_not_contains: Bytes
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [HMApprovalEvent_filter]
  or: [HMApprovalEvent_filter]
}

enum HMApprovalEvent_orderBy {
  id
  token
  owner
  spender
  value
  block
  timestamp
  transaction
  count
}

type HMBulkApprovalEvent {
  id: ID!
  bulkCount: BigInt!
  txId: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
  count: BigInt
}

input HMBulkApprovalEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  bulkCount: BigInt
  bulkCount_not: BigInt
  bulkCount_gt: BigInt
  bulkCount_lt: BigInt
  bulkCount_gte: BigInt
  bulkCount_lte: BigInt
  bulkCount_in: [BigInt!]
  bulkCount_not_in: [BigInt!]
  txId: BigInt
  txId_not: BigInt
  txId_gt: BigInt
  txId_lt: BigInt
  txId_gte: BigInt
  txId_lte: BigInt
  txId_in: [BigInt!]
  txId_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [HMBulkApprovalEvent_filter]
  or: [HMBulkApprovalEvent_filter]
}

enum HMBulkApprovalEvent_orderBy {
  id
  bulkCount
  txId
  block
  timestamp
  transaction
  count
}

type HMBulkTransferEvent {
  id: ID!
  bulkCount: BigInt!
  txId: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
  count: BigInt
}

input HMBulkTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  bulkCount: BigInt
  bulkCount_not: BigInt
  bulkCount_gt: BigInt
  bulkCount_lt: BigInt
  bulkCount_gte: BigInt
  bulkCount_lte: BigInt
  bulkCount_in: [BigInt!]
  bulkCount_not_in: [BigInt!]
  txId: BigInt
  txId_not: BigInt
  txId_gt: BigInt
  txId_lt: BigInt
  txId_gte: BigInt
  txId_lte: BigInt
  txId_in: [BigInt!]
  txId_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [HMBulkTransferEvent_filter]
  or: [HMBulkTransferEvent_filter]
}

enum HMBulkTransferEvent_orderBy {
  id
  bulkCount
  txId
  block
  timestamp
  transaction
  count
}

type HMTokenStatistics {
  id: ID!
  totalTransferEventCount: BigInt!
  totalApprovalEventCount: BigInt!
  totalBulkApprovalEventCount: BigInt!
  totalBulkTransferEventCount: BigInt!
  totalValueTransfered: BigInt!
  token: Bytes!
  holders: BigInt!
}

input HMTokenStatistics_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  totalTransferEventCount: BigInt
  totalTransferEventCount_not: BigInt
  totalTransferEventCount_gt: BigInt
  totalTransferEventCount_lt: BigInt
  totalTransferEventCount_gte: BigInt
  totalTransferEventCount_lte: BigInt
  totalTransferEventCount_in: [BigInt!]
  totalTransferEventCount_not_in: [BigInt!]
  totalApprovalEventCount: BigInt
  totalApprovalEventCount_not: BigInt
  totalApprovalEventCount_gt: BigInt
  totalApprovalEventCount_lt: BigInt
  totalApprovalEventCount_gte: BigInt
  totalApprovalEventCount_lte: BigInt
  totalApprovalEventCount_in: [BigInt!]
  totalApprovalEventCount_not_in: [BigInt!]
  totalBulkApprovalEventCount: BigInt
  totalBulkApprovalEventCount_not: BigInt
  totalBulkApprovalEventCount_gt: BigInt
  totalBulkApprovalEventCount_lt: BigInt
  totalBulkApprovalEventCount_gte: BigInt
  totalBulkApprovalEventCount_lte: BigInt
  totalBulkApprovalEventCount_in: [BigInt!]
  totalBulkApprovalEventCount_not_in: [BigInt!]
  totalBulkTransferEventCount: BigInt
  totalBulkTransferEventCount_not: BigInt
  totalBulkTransferEventCount_gt: BigInt
  totalBulkTransferEventCount_lt: BigInt
  totalBulkTransferEventCount_gte: BigInt
  totalBulkTransferEventCount_lte: BigInt
  totalBulkTransferEventCount_in: [BigInt!]
  totalBulkTransferEventCount_not_in: [BigInt!]
  totalValueTransfered: BigInt
  totalValueTransfered_not: BigInt
  totalValueTransfered_gt: BigInt
  totalValueTransfered_lt: BigInt
  totalValueTransfered_gte: BigInt
  totalValueTransfered_lte: BigInt
  totalValueTransfered_in: [BigInt!]
  totalValueTransfered_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  holders: BigInt
  holders_not: BigInt
  holders_gt: BigInt
  holders_lt: BigInt
  holders_gte: BigInt
  holders_lte: BigInt
  holders_in: [BigInt!]
  holders_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [HMTokenStatistics_filter]
  or: [HMTokenStatistics_filter]
}

enum HMTokenStatistics_orderBy {
  id
  totalTransferEventCount
  totalApprovalEventCount
  totalBulkApprovalEventCount
  totalBulkTransferEventCount
  totalValueTransfered
  token
  holders
}

type HMTransferEvent {
  id: ID!
  token: Bytes!
  from: Bytes
  to: Bytes
  value: BigInt
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
  count: BigInt
}

input HMTransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  from: Bytes
  from_not: Bytes
  from_gt: Bytes
  from_lt: Bytes
  from_gte: Bytes
  from_lte: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_gt: Bytes
  to_lt: Bytes
  to_gte: Bytes
  to_lte: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [HMTransferEvent_filter]
  or: [HMTransferEvent_filter]
}

enum HMTransferEvent_orderBy {
  id
  token
  from
  to
  value
  block
  timestamp
  transaction
  count
}

type Holder {
  id: ID!
  address: Bytes!
  balance: BigInt!
}

input Holder_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Holder_filter]
  or: [Holder_filter]
}

enum Holder_orderBy {
  id
  address
  balance
}

type ISEvent {
  id: ID!
  timestamp: BigInt!
  sender: Bytes
  _url: String!
  _hash: String!
  count: BigInt
}

input ISEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  _url: String
  _url_not: String
  _url_gt: String
  _url_lt: String
  _url_gte: String
  _url_lte: String
  _url_in: [String!]
  _url_not_in: [String!]
  _url_contains: String
  _url_contains_nocase: String
  _url_not_contains: String
  _url_not_contains_nocase: String
  _url_starts_with: String
  _url_starts_with_nocase: String
  _url_not_starts_with: String
  _url_not_starts_with_nocase: String
  _url_ends_with: String
  _url_ends_with_nocase: String
  _url_not_ends_with: String
  _url_not_ends_with_nocase: String
  _hash: String
  _hash_not: String
  _hash_gt: String
  _hash_lt: String
  _hash_gte: String
  _hash_lte: String
  _hash_in: [String!]
  _hash_not_in: [String!]
  _hash_contains: String
  _hash_contains_nocase: String
  _hash_not_contains: String
  _hash_not_contains_nocase: String
  _hash_starts_with: String
  _hash_starts_with_nocase: String
  _hash_not_starts_with: String
  _hash_not_starts_with_nocase: String
  _hash_ends_with: String
  _hash_ends_with_nocase: String
  _hash_not_ends_with: String
  _hash_not_ends_with_nocase: String
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ISEvent_filter]
  or: [ISEvent_filter]
}

enum ISEvent_orderBy {
  id
  timestamp
  sender
  _url
  _hash
  count
}

type LaunchedEscrow {
  id: ID!
  token: Bytes!
  from: Bytes!
  timestamp: BigInt!
  count: BigInt
  amountAllocated: BigInt
  amountPayout: BigInt
  status: String
}

input LaunchedEscrow_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  from: Bytes
  from_not: Bytes
  from_gt: Bytes
  from_lt: Bytes
  from_gte: Bytes
  from_lte: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]
  amountAllocated: BigInt
  amountAllocated_not: BigInt
  amountAllocated_gt: BigInt
  amountAllocated_lt: BigInt
  amountAllocated_gte: BigInt
  amountAllocated_lte: BigInt
  amountAllocated_in: [BigInt!]
  amountAllocated_not_in: [BigInt!]
  amountPayout: BigInt
  amountPayout_not: BigInt
  amountPayout_gt: BigInt
  amountPayout_lt: BigInt
  amountPayout_gte: BigInt
  amountPayout_lte: BigInt
  amountPayout_in: [BigInt!]
  amountPayout_not_in: [BigInt!]
  status: String
  status_not: String
  status_gt: String
  status_lt: String
  status_gte: String
  status_lte: String
  status_in: [String!]
  status_not_in: [String!]
  status_contains: String
  status_contains_nocase: String
  status_not_contains: String
  status_not_contains_nocase: String
  status_starts_with: String
  status_starts_with_nocase: String
  status_not_starts_with: String
  status_not_starts_with_nocase: String
  status_ends_with: String
  status_ends_with_nocase: String
  status_not_ends_with: String
  status_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LaunchedEscrow_filter]
  or: [LaunchedEscrow_filter]
}

enum LaunchedEscrow_orderBy {
  id
  token
  from
  timestamp
  count
  amountAllocated
  amountPayout
  status
}

type Leader {
  id: ID!
  address: Bytes!
  role: String!
  amountStaked: BigInt!
  amountAllocated: BigInt!
  amountLocked: BigInt!
  lockedUntilTimestamp: BigInt!
  amountWithdrawn: BigInt!
  amountSlashed: BigInt!
  reputation: BigInt!
  reward: BigInt
  amountJobsLaunched: BigInt!
}

input Leader_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  role: String
  role_not: String
  role_gt: String
  role_lt: String
  role_gte: String
  role_lte: String
  role_in: [String!]
  role_not_in: [String!]
  role_contains: String
  role_contains_nocase: String
  role_not_contains: String
  role_not_contains_nocase: String
  role_starts_with: String
  role_starts_with_nocase: String
  role_not_starts_with: String
  role_not_starts_with_nocase: String
  role_ends_with: String
  role_ends_with_nocase: String
  role_not_ends_with: String
  role_not_ends_with_nocase: String
  amountStaked: BigInt
  amountStaked_not: BigInt
  amountStaked_gt: BigInt
  amountStaked_lt: BigInt
  amountStaked_gte: BigInt
  amountStaked_lte: BigInt
  amountStaked_in: [BigInt!]
  amountStaked_not_in: [BigInt!]
  amountAllocated: BigInt
  amountAllocated_not: BigInt
  amountAllocated_gt: BigInt
  amountAllocated_lt: BigInt
  amountAllocated_gte: BigInt
  amountAllocated_lte: BigInt
  amountAllocated_in: [BigInt!]
  amountAllocated_not_in: [BigInt!]
  amountLocked: BigInt
  amountLocked_not: BigInt
  amountLocked_gt: BigInt
  amountLocked_lt: BigInt
  amountLocked_gte: BigInt
  amountLocked_lte: BigInt
  amountLocked_in: [BigInt!]
  amountLocked_not_in: [BigInt!]
  lockedUntilTimestamp: BigInt
  lockedUntilTimestamp_not: BigInt
  lockedUntilTimestamp_gt: BigInt
  lockedUntilTimestamp_lt: BigInt
  lockedUntilTimestamp_gte: BigInt
  lockedUntilTimestamp_lte: BigInt
  lockedUntilTimestamp_in: [BigInt!]
  lockedUntilTimestamp_not_in: [BigInt!]
  amountWithdrawn: BigInt
  amountWithdrawn_not: BigInt
  amountWithdrawn_gt: BigInt
  amountWithdrawn_lt: BigInt
  amountWithdrawn_gte: BigInt
  amountWithdrawn_lte: BigInt
  amountWithdrawn_in: [BigInt!]
  amountWithdrawn_not_in: [BigInt!]
  amountSlashed: BigInt
  amountSlashed_not: BigInt
  amountSlashed_gt: BigInt
  amountSlashed_lt: BigInt
  amountSlashed_gte: BigInt
  amountSlashed_lte: BigInt
  amountSlashed_in: [BigInt!]
  amountSlashed_not_in: [BigInt!]
  reputation: BigInt
  reputation_not: BigInt
  reputation_gt: BigInt
  reputation_lt: BigInt
  reputation_gte: BigInt
  reputation_lte: BigInt
  reputation_in: [BigInt!]
  reputation_not_in: [BigInt!]
  reward: BigInt
  reward_not: BigInt
  reward_gt: BigInt
  reward_lt: BigInt
  reward_gte: BigInt
  reward_lte: BigInt
  reward_in: [BigInt!]
  reward_not_in: [BigInt!]
  amountJobsLaunched: BigInt
  amountJobsLaunched_not: BigInt
  amountJobsLaunched_gt: BigInt
  amountJobsLaunched_lt: BigInt
  amountJobsLaunched_gte: BigInt
  amountJobsLaunched_lte: BigInt
  amountJobsLaunched_in: [BigInt!]
  amountJobsLaunched_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Leader_filter]
  or: [Leader_filter]
}

enum Leader_orderBy {
  id
  address
  role
  amountStaked
  amountAllocated
  amountLocked
  lockedUntilTimestamp
  amountWithdrawn
  amountSlashed
  reputation
  reward
  amountJobsLaunched
}

type LeaderStatistics {
  id: ID!
  leaders: BigInt!
}

input LeaderStatistics_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  leaders: BigInt
  leaders_not: BigInt
  leaders_gt: BigInt
  leaders_lt: BigInt
  leaders_gte: BigInt
  leaders_lte: BigInt
  leaders_in: [BigInt!]
  leaders_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LeaderStatistics_filter]
  or: [LeaderStatistics_filter]
}

enum LeaderStatistics_orderBy {
  id
  leaders
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Payment {
  id: ID!
  address: Bytes!
  amount: BigInt!
}

input Payment_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Payment_filter]
  or: [Payment_filter]
}

enum Payment_orderBy {
  id
  address
  amount
}

type PEvent {
  id: ID!
  timestamp: BigInt!
  _url: String!
  _hash: String!
  count: BigInt
}

input PEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  _url: String
  _url_not: String
  _url_gt: String
  _url_lt: String
  _url_gte: String
  _url_lte: String
  _url_in: [String!]
  _url_not_in: [String!]
  _url_contains: String
  _url_contains_nocase: String
  _url_not_contains: String
  _url_not_contains_nocase: String
  _url_starts_with: String
  _url_starts_with_nocase: String
  _url_not_starts_with: String
  _url_not_starts_with_nocase: String
  _url_ends_with: String
  _url_ends_with_nocase: String
  _url_not_ends_with: String
  _url_not_ends_with_nocase: String
  _hash: String
  _hash_not: String
  _hash_gt: String
  _hash_lt: String
  _hash_gte: String
  _hash_lte: String
  _hash_in: [String!]
  _hash_not_in: [String!]
  _hash_contains: String
  _hash_contains_nocase: String
  _hash_not_contains: String
  _hash_not_contains_nocase: String
  _hash_starts_with: String
  _hash_starts_with_nocase: String
  _hash_not_starts_with: String
  _hash_not_starts_with_nocase: String
  _hash_ends_with: String
  _hash_ends_with_nocase: String
  _hash_not_ends_with: String
  _hash_not_ends_with_nocase: String
  count: BigInt
  count_not: BigInt
  count_gt: BigInt
  count_lt: BigInt
  count_gte: BigInt
  count_lte: BigInt
  count_in: [BigInt!]
  count_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PEvent_filter]
  or: [PEvent_filter]
}

enum PEvent_orderBy {
  id
  timestamp
  _url
  _hash
  count
}

type Query {
  launchedEscrow(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LaunchedEscrow
  launchedEscrows(
    skip: Int = 0
    first: Int = 100
    orderBy: LaunchedEscrow_orderBy
    orderDirection: OrderDirection
    where: LaunchedEscrow_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LaunchedEscrow!]!
  isevent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ISEvent
  isevents(
    skip: Int = 0
    first: Int = 100
    orderBy: ISEvent_orderBy
    orderDirection: OrderDirection
    where: ISEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ISEvent!]!
  pevent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PEvent
  pevents(
    skip: Int = 0
    first: Int = 100
    orderBy: PEvent_orderBy
    orderDirection: OrderDirection
    where: PEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PEvent!]!
  bulkTransferEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BulkTransferEvent
  bulkTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BulkTransferEvent_orderBy
    orderDirection: OrderDirection
    where: BulkTransferEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BulkTransferEvent!]!
  escrowStatistics(
    skip: Int = 0
    first: Int = 100
    orderBy: EscrowStatistics_orderBy
    orderDirection: OrderDirection
    where: EscrowStatistics_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EscrowStatistics!]!
  hmtransferEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HMTransferEvent
  hmtransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: HMTransferEvent_orderBy
    orderDirection: OrderDirection
    where: HMTransferEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HMTransferEvent!]!
  hmbulkTransferEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HMBulkTransferEvent
  hmbulkTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: HMBulkTransferEvent_orderBy
    orderDirection: OrderDirection
    where: HMBulkTransferEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HMBulkTransferEvent!]!
  hmapprovalEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HMApprovalEvent
  hmapprovalEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: HMApprovalEvent_orderBy
    orderDirection: OrderDirection
    where: HMApprovalEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HMApprovalEvent!]!
  hmbulkApprovalEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HMBulkApprovalEvent
  hmbulkApprovalEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: HMBulkApprovalEvent_orderBy
    orderDirection: OrderDirection
    where: HMBulkApprovalEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HMBulkApprovalEvent!]!
  hmtokenStatistics(
    skip: Int = 0
    first: Int = 100
    orderBy: HMTokenStatistics_orderBy
    orderDirection: OrderDirection
    where: HMTokenStatistics_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HMTokenStatistics!]!
  holder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Holder
  holders(
    skip: Int = 0
    first: Int = 100
    orderBy: Holder_orderBy
    orderDirection: OrderDirection
    where: Holder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Holder!]!
  eventDayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EventDayData
  eventDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: EventDayData_orderBy
    orderDirection: OrderDirection
    where: EventDayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EventDayData!]!
  leaderStatistics(
    skip: Int = 0
    first: Int = 100
    orderBy: LeaderStatistics_orderBy
    orderDirection: OrderDirection
    where: LeaderStatistics_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeaderStatistics!]!
  leader(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Leader
  leaders(
    skip: Int = 0
    first: Int = 100
    orderBy: Leader_orderBy
    orderDirection: OrderDirection
    where: Leader_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Leader!]!
  dataSavedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DataSavedEvent
  dataSavedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DataSavedEvent_orderBy
    orderDirection: OrderDirection
    where: DataSavedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DataSavedEvent!]!
  stakeDepositedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeDepositedEvent
  stakeDepositedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeDepositedEvent_orderBy
    orderDirection: OrderDirection
    where: StakeDepositedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeDepositedEvent!]!
  stakeLockedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeLockedEvent
  stakeLockedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeLockedEvent_orderBy
    orderDirection: OrderDirection
    where: StakeLockedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeLockedEvent!]!
  stakeWithdrawnEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeWithdrawnEvent
  stakeWithdrawnEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeWithdrawnEvent_orderBy
    orderDirection: OrderDirection
    where: StakeWithdrawnEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeWithdrawnEvent!]!
  stakeSlashedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeSlashedEvent
  stakeSlashedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeSlashedEvent_orderBy
    orderDirection: OrderDirection
    where: StakeSlashedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeSlashedEvent!]!
  stakeAllocatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeAllocatedEvent
  stakeAllocatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeAllocatedEvent_orderBy
    orderDirection: OrderDirection
    where: StakeAllocatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeAllocatedEvent!]!
  allocationClosedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AllocationClosedEvent
  allocationClosedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AllocationClosedEvent_orderBy
    orderDirection: OrderDirection
    where: AllocationClosedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AllocationClosedEvent!]!
  rewardAddedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardAddedEvent
  rewardAddedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardAddedEvent_orderBy
    orderDirection: OrderDirection
    where: RewardAddedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardAddedEvent!]!
  worker(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Worker
  workers(
    skip: Int = 0
    first: Int = 100
    orderBy: Worker_orderBy
    orderDirection: OrderDirection
    where: Worker_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Worker!]!
  payment(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Payment
  payments(
    skip: Int = 0
    first: Int = 100
    orderBy: Payment_orderBy
    orderDirection: OrderDirection
    where: Payment_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Payment!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type RewardAddedEvent {
  id: ID!
  escrow: Bytes!
  staker: Bytes!
  amount: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

input RewardAddedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  escrow: Bytes
  escrow_not: Bytes
  escrow_gt: Bytes
  escrow_lt: Bytes
  escrow_gte: Bytes
  escrow_lte: Bytes
  escrow_in: [Bytes!]
  escrow_not_in: [Bytes!]
  escrow_contains: Bytes
  escrow_not_contains: Bytes
  staker: Bytes
  staker_not: Bytes
  staker_gt: Bytes
  staker_lt: Bytes
  staker_gte: Bytes
  staker_lte: Bytes
  staker_in: [Bytes!]
  staker_not_in: [Bytes!]
  staker_contains: Bytes
  staker_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RewardAddedEvent_filter]
  or: [RewardAddedEvent_filter]
}

enum RewardAddedEvent_orderBy {
  id
  escrow
  staker
  amount
  block
  timestamp
  transaction
}

type StakeAllocatedEvent {
  id: ID!
  staker: Bytes!
  amount: BigInt!
  escrow: Bytes!
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

input StakeAllocatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  staker: Bytes
  staker_not: Bytes
  staker_gt: Bytes
  staker_lt: Bytes
  staker_gte: Bytes
  staker_lte: Bytes
  staker_in: [Bytes!]
  staker_not_in: [Bytes!]
  staker_contains: Bytes
  staker_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  escrow: Bytes
  escrow_not: Bytes
  escrow_gt: Bytes
  escrow_lt: Bytes
  escrow_gte: Bytes
  escrow_lte: Bytes
  escrow_in: [Bytes!]
  escrow_not_in: [Bytes!]
  escrow_contains: Bytes
  escrow_not_contains: Bytes
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeAllocatedEvent_filter]
  or: [StakeAllocatedEvent_filter]
}

enum StakeAllocatedEvent_orderBy {
  id
  staker
  amount
  escrow
  block
  timestamp
  transaction
}

type StakeDepositedEvent {
  id: ID!
  staker: Bytes!
  amount: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

input StakeDepositedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  staker: Bytes
  staker_not: Bytes
  staker_gt: Bytes
  staker_lt: Bytes
  staker_gte: Bytes
  staker_lte: Bytes
  staker_in: [Bytes!]
  staker_not_in: [Bytes!]
  staker_contains: Bytes
  staker_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeDepositedEvent_filter]
  or: [StakeDepositedEvent_filter]
}

enum StakeDepositedEvent_orderBy {
  id
  staker
  amount
  block
  timestamp
  transaction
}

type StakeLockedEvent {
  id: ID!
  staker: Bytes!
  amount: BigInt!
  lockedUntilTimestamp: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

input StakeLockedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  staker: Bytes
  staker_not: Bytes
  staker_gt: Bytes
  staker_lt: Bytes
  staker_gte: Bytes
  staker_lte: Bytes
  staker_in: [Bytes!]
  staker_not_in: [Bytes!]
  staker_contains: Bytes
  staker_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  lockedUntilTimestamp: BigInt
  lockedUntilTimestamp_not: BigInt
  lockedUntilTimestamp_gt: BigInt
  lockedUntilTimestamp_lt: BigInt
  lockedUntilTimestamp_gte: BigInt
  lockedUntilTimestamp_lte: BigInt
  lockedUntilTimestamp_in: [BigInt!]
  lockedUntilTimestamp_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeLockedEvent_filter]
  or: [StakeLockedEvent_filter]
}

enum StakeLockedEvent_orderBy {
  id
  staker
  amount
  lockedUntilTimestamp
  block
  timestamp
  transaction
}

type StakeSlashedEvent {
  id: ID!
  staker: Bytes!
  amount: BigInt!
  escrow: Bytes!
  slasher: Bytes!
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

input StakeSlashedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  staker: Bytes
  staker_not: Bytes
  staker_gt: Bytes
  staker_lt: Bytes
  staker_gte: Bytes
  staker_lte: Bytes
  staker_in: [Bytes!]
  staker_not_in: [Bytes!]
  staker_contains: Bytes
  staker_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  escrow: Bytes
  escrow_not: Bytes
  escrow_gt: Bytes
  escrow_lt: Bytes
  escrow_gte: Bytes
  escrow_lte: Bytes
  escrow_in: [Bytes!]
  escrow_not_in: [Bytes!]
  escrow_contains: Bytes
  escrow_not_contains: Bytes
  slasher: Bytes
  slasher_not: Bytes
  slasher_gt: Bytes
  slasher_lt: Bytes
  slasher_gte: Bytes
  slasher_lte: Bytes
  slasher_in: [Bytes!]
  slasher_not_in: [Bytes!]
  slasher_contains: Bytes
  slasher_not_contains: Bytes
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeSlashedEvent_filter]
  or: [StakeSlashedEvent_filter]
}

enum StakeSlashedEvent_orderBy {
  id
  staker
  amount
  escrow
  slasher
  block
  timestamp
  transaction
}

type StakeWithdrawnEvent {
  id: ID!
  staker: Bytes!
  amount: BigInt!
  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

input StakeWithdrawnEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  staker: Bytes
  staker_not: Bytes
  staker_gt: Bytes
  staker_lt: Bytes
  staker_gte: Bytes
  staker_lte: Bytes
  staker_in: [Bytes!]
  staker_not_in: [Bytes!]
  staker_contains: Bytes
  staker_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transaction: Bytes
  transaction_not: Bytes
  transaction_gt: Bytes
  transaction_lt: Bytes
  transaction_gte: Bytes
  transaction_lte: Bytes
  transaction_in: [Bytes!]
  transaction_not_in: [Bytes!]
  transaction_contains: Bytes
  transaction_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeWithdrawnEvent_filter]
  or: [StakeWithdrawnEvent_filter]
}

enum StakeWithdrawnEvent_orderBy {
  id
  staker
  amount
  block
  timestamp
  transaction
}

type Subscription {
  launchedEscrow(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LaunchedEscrow
  launchedEscrows(
    skip: Int = 0
    first: Int = 100
    orderBy: LaunchedEscrow_orderBy
    orderDirection: OrderDirection
    where: LaunchedEscrow_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LaunchedEscrow!]!
  isevent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ISEvent
  isevents(
    skip: Int = 0
    first: Int = 100
    orderBy: ISEvent_orderBy
    orderDirection: OrderDirection
    where: ISEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ISEvent!]!
  pevent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PEvent
  pevents(
    skip: Int = 0
    first: Int = 100
    orderBy: PEvent_orderBy
    orderDirection: OrderDirection
    where: PEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PEvent!]!
  bulkTransferEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BulkTransferEvent
  bulkTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BulkTransferEvent_orderBy
    orderDirection: OrderDirection
    where: BulkTransferEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BulkTransferEvent!]!
  escrowStatistics(
    skip: Int = 0
    first: Int = 100
    orderBy: EscrowStatistics_orderBy
    orderDirection: OrderDirection
    where: EscrowStatistics_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EscrowStatistics!]!
  hmtransferEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HMTransferEvent
  hmtransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: HMTransferEvent_orderBy
    orderDirection: OrderDirection
    where: HMTransferEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HMTransferEvent!]!
  hmbulkTransferEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HMBulkTransferEvent
  hmbulkTransferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: HMBulkTransferEvent_orderBy
    orderDirection: OrderDirection
    where: HMBulkTransferEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HMBulkTransferEvent!]!
  hmapprovalEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HMApprovalEvent
  hmapprovalEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: HMApprovalEvent_orderBy
    orderDirection: OrderDirection
    where: HMApprovalEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HMApprovalEvent!]!
  hmbulkApprovalEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HMBulkApprovalEvent
  hmbulkApprovalEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: HMBulkApprovalEvent_orderBy
    orderDirection: OrderDirection
    where: HMBulkApprovalEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HMBulkApprovalEvent!]!
  hmtokenStatistics(
    skip: Int = 0
    first: Int = 100
    orderBy: HMTokenStatistics_orderBy
    orderDirection: OrderDirection
    where: HMTokenStatistics_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HMTokenStatistics!]!
  holder(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Holder
  holders(
    skip: Int = 0
    first: Int = 100
    orderBy: Holder_orderBy
    orderDirection: OrderDirection
    where: Holder_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Holder!]!
  eventDayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EventDayData
  eventDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: EventDayData_orderBy
    orderDirection: OrderDirection
    where: EventDayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EventDayData!]!
  leaderStatistics(
    skip: Int = 0
    first: Int = 100
    orderBy: LeaderStatistics_orderBy
    orderDirection: OrderDirection
    where: LeaderStatistics_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LeaderStatistics!]!
  leader(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Leader
  leaders(
    skip: Int = 0
    first: Int = 100
    orderBy: Leader_orderBy
    orderDirection: OrderDirection
    where: Leader_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Leader!]!
  dataSavedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DataSavedEvent
  dataSavedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DataSavedEvent_orderBy
    orderDirection: OrderDirection
    where: DataSavedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DataSavedEvent!]!
  stakeDepositedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeDepositedEvent
  stakeDepositedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeDepositedEvent_orderBy
    orderDirection: OrderDirection
    where: StakeDepositedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeDepositedEvent!]!
  stakeLockedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeLockedEvent
  stakeLockedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeLockedEvent_orderBy
    orderDirection: OrderDirection
    where: StakeLockedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeLockedEvent!]!
  stakeWithdrawnEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeWithdrawnEvent
  stakeWithdrawnEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeWithdrawnEvent_orderBy
    orderDirection: OrderDirection
    where: StakeWithdrawnEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeWithdrawnEvent!]!
  stakeSlashedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeSlashedEvent
  stakeSlashedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeSlashedEvent_orderBy
    orderDirection: OrderDirection
    where: StakeSlashedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeSlashedEvent!]!
  stakeAllocatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeAllocatedEvent
  stakeAllocatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeAllocatedEvent_orderBy
    orderDirection: OrderDirection
    where: StakeAllocatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeAllocatedEvent!]!
  allocationClosedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AllocationClosedEvent
  allocationClosedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AllocationClosedEvent_orderBy
    orderDirection: OrderDirection
    where: AllocationClosedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AllocationClosedEvent!]!
  rewardAddedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardAddedEvent
  rewardAddedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardAddedEvent_orderBy
    orderDirection: OrderDirection
    where: RewardAddedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardAddedEvent!]!
  worker(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Worker
  workers(
    skip: Int = 0
    first: Int = 100
    orderBy: Worker_orderBy
    orderDirection: OrderDirection
    where: Worker_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Worker!]!
  payment(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Payment
  payments(
    skip: Int = 0
    first: Int = 100
    orderBy: Payment_orderBy
    orderDirection: OrderDirection
    where: Payment_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Payment!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Worker {
  id: ID!
  address: Bytes!
  amountReceived: BigInt!
  amountJobsSolved: BigInt!
  amountJobsSolvedPaid: BigInt!
}

input Worker_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  amountReceived: BigInt
  amountReceived_not: BigInt
  amountReceived_gt: BigInt
  amountReceived_lt: BigInt
  amountReceived_gte: BigInt
  amountReceived_lte: BigInt
  amountReceived_in: [BigInt!]
  amountReceived_not_in: [BigInt!]
  amountJobsSolved: BigInt
  amountJobsSolved_not: BigInt
  amountJobsSolved_gt: BigInt
  amountJobsSolved_lt: BigInt
  amountJobsSolved_gte: BigInt
  amountJobsSolved_lte: BigInt
  amountJobsSolved_in: [BigInt!]
  amountJobsSolved_not_in: [BigInt!]
  amountJobsSolvedPaid: BigInt
  amountJobsSolvedPaid_not: BigInt
  amountJobsSolvedPaid_gt: BigInt
  amountJobsSolvedPaid_lt: BigInt
  amountJobsSolvedPaid_gte: BigInt
  amountJobsSolvedPaid_lte: BigInt
  amountJobsSolvedPaid_in: [BigInt!]
  amountJobsSolvedPaid_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Worker_filter]
  or: [Worker_filter]
}

enum Worker_orderBy {
  id
  address
  amountReceived
  amountJobsSolved
  amountJobsSolvedPaid
}
